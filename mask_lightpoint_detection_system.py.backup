#!/usr/bin/env python3
"""
基于mask.png的光点检测系统
将mask中的每个白色连通区域识别为一个独立的光点
"""

import cv2
import numpy as np
import time
import threading
import logging
import sys
import os
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from mqtt_camera_monitoring.config import ConfigManager
from mqtt_camera_monitoring.mqtt_client import MQTTClient

@dataclass
class LightPoint:
    """光点信息"""
    id: int
    center_x: int
    center_y: int
    area: int
    contour: np.ndarray
    baseline_is_red: bool = False
    current_is_red: bool = False
    changed: bool = False

@dataclass
class CameraLightPointState:
    """摄像头光点检测状态"""
    camera_id: int
    light_points: List[LightPoint] = None
    baseline_red_count: int = 0
    current_red_count: int = 0
    baseline_established: bool = False
    last_detection_time: float = 0.0
    detection_count: int = 0

class MaskLightPointDetectionSystem:
    """基于mask.png的光点检测系统"""
    
    def __init__(self, config_file: str = "config.yaml", mask_file: str = "mask.png"):
        self.logger = logging.getLogger(__name__)
        
        # 加载配置
        config_manager = ConfigManager(config_file)
        self.config = config_manager.load_config()
        
        # 加载mask图片
        self.mask_file = mask_file
        self.mask_image = None
        self.light_points_template = []  # 光点模板
        
        if not self._load_mask():
            raise ValueError(f"无法加载mask文件: {mask_file}")
        
        # 系统状态
        self.running = False
        self.mqtt_triggered = False
        self.baseline_capture_time = 0.0
        
        # 摄像头和检测器
        self.cameras: List[Optional[cv2.VideoCapture]] = []
        self.camera_states: Dict[int, CameraLightPointState] = {}
        
        # MQTT客户端
        self.mqtt_client: Optional[MQTTClient] = None
        
        # 线程控制
        self.detection_thread: Optional[threading.Thread] = None
        self.detection_lock = threading.Lock()
        
        # 红色检测参数 - 更宽松的检测范围
        self.red_hsv_lower1 = np.array([0, 30, 30])      # 降低饱和度和亮度要求
        self.red_hsv_upper1 = np.array([25, 255, 255])   # 扩大色调范围
        self.red_hsv_lower2 = np.array([155, 30, 30])    # 扩大第二范围
        self.red_hsv_upper2 = np.array([180, 255, 255])
        
        self.logger.info(f"基于mask.png的光点检测系统初始化完成，光点数: {len(self.light_points_template)}")
    
    def _load_mask(self) -> bool:
        """加载mask图片并识别白色连通区域作为光点"""
        if not os.path.exists(self.mask_file):
            self.logger.error(f"Mask文件不存在: {self.mask_file}")
            return False
        
        # 读取mask图片
        mask_img = cv2.imread(self.mask_file, cv2.IMREAD_GRAYSCALE)
        if mask_img is None:
            self.logger.error(f"无法读取mask文件: {self.mask_file}")
            return False
        
        self.logger.info(f"Mask原始尺寸: {mask_img.shape}")
        
        # 目标1080p分辨率
        target_width, target_height = 1920, 1080
        
        # 如果mask尺寸与目标不匹配，进行缩放
        if mask_img.shape != (target_height, target_width):
            self.logger.info(f"缩放mask到1080p: ({target_height}, {target_width})")
            mask_img = cv2.resize(mask_img, (target_width, target_height), interpolation=cv2.INTER_NEAREST)
            self.logger.info(f"Mask缩放后尺寸: {mask_img.shape}")
        
        self.mask_image = mask_img
        
        # 创建二值化mask (白色区域 > 200)
        binary_mask = (mask_img > 200).astype(np.uint8) * 255
        
        # 查找白色连通区域
        contours, _ = cv2.findContours(binary_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        # 创建光点模板
        self.light_points_template = []
        for i, contour in enumerate(contours):
            # 计算面积，过滤太小的区域
            area = cv2.contourArea(contour)
            if area < 10:  # 最小面积阈值
                continue
            
            # 计算中心点
            M = cv2.moments(contour)
            if M["m00"] != 0:
                center_x = int(M["m10"] / M["m00"])
                center_y = int(M["m01"] / M["m00"])
            else:
                # 如果无法计算质心，使用边界框中心
                x, y, w, h = cv2.boundingRect(contour)
                center_x = x + w // 2
                center_y = y + h // 2
            
            # 创建光点对象
            light_point = LightPoint(
                id=i,
                center_x=center_x,
                center_y=center_y,
                area=int(area),
                contour=contour
            )
            
            self.light_points_template.append(light_point)
        
        self.logger.info(f"最终Mask尺寸: {mask_img.shape}")
        self.logger.info(f"识别到 {len(self.light_points_template)} 个光点区域")
        
        # 输出光点统计信息
        if self.light_points_template:
            areas = [lp.area for lp in self.light_points_template]
            self.logger.info(f"光点面积统计: 最小={min(areas)}, 最大={max(areas)}, 平均={sum(areas)/len(areas):.1f}")
        
        return len(self.light_points_template) > 0
    
    def _is_red_color(self, bgr_color: Tuple[int, int, int]) -> bool:
        """判断BGR颜色是否为红色"""
        # 转换为HSV
        bgr_pixel = np.uint8([[bgr_color]])
        hsv_pixel = cv2.cvtColor(bgr_pixel, cv2.COLOR_BGR2HSV)[0][0]
        
        # 检查是否在红色HSV范围内
        in_range1 = (self.red_hsv_lower1[0] <= hsv_pixel[0] <= self.red_hsv_upper1[0] and
                     self.red_hsv_lower1[1] <= hsv_pixel[1] <= self.red_hsv_upper1[1] and
                     self.red_hsv_lower1[2] <= hsv_pixel[2] <= self.red_hsv_upper1[2])
        
        in_range2 = (self.red_hsv_lower2[0] <= hsv_pixel[0] <= self.red_hsv_upper2[0] and
                     self.red_hsv_lower2[1] <= hsv_pixel[1] <= self.red_hsv_upper2[1] and
                     self.red_hsv_lower2[2] <= hsv_pixel[2] <= self.red_hsv_upper2[2])
        
        return in_range1 or in_range2
    
    def _check_light_point_red(self, frame: np.ndarray, light_point: LightPoint) -> bool:
        """检查光点区域是否为红色"""
        # 创建光点区域的mask
        point_mask = np.zeros(frame.shape[:2], dtype=np.uint8)
        cv2.fillPoly(point_mask, [light_point.contour], 255)
        
        # 提取光点区域的像素
        masked_pixels = frame[point_mask > 0]
        
        if len(masked_pixels) == 0:
            self.logger.debug(f"光点 {light_point.id}: 无像素数据")
            return False
        
        # 检查区域内红色像素的比例
        red_pixel_count = 0
        total_pixels = len(masked_pixels)
        
        # 采样检查（如果像素太多，进行采样以提高性能）
        sample_size = min(100, total_pixels)
        step = max(1, total_pixels // sample_size)
        
        for i in range(0, total_pixels, step):
            bgr_color = tuple(masked_pixels[i].astype(int))
            if self._is_red_color(bgr_color):
                red_pixel_count += 1
        
        # 如果红色像素比例超过阈值，认为该光点为红色
        red_ratio = red_pixel_count / (total_pixels // step)
        is_red = red_ratio > 0.1  # 降低到10%的像素为红色就认为是红色光点
        
        self.logger.info(f"光点 {light_point.id}: 像素数={total_pixels}, 红色比例={red_ratio:.3f}, 结果={'红色' if is_red else '非红色'}")
        
        return is_red
    
    def _extract_red_light_points(self, frame: np.ndarray) -> List[LightPoint]:
        """提取当前帧中的红色光点"""
        red_light_points = []
        
        self.logger.info(f"开始检测红色光点，总光点数: {len(self.light_points_template)}")
        
        for template_point in self.light_points_template:
            # 检查该光点区域是否为红色
            is_red = self._check_light_point_red(frame, template_point)
            
            # 改为info级别，确保能看到每个光点的检测结果
            self.logger.info(f"光点 {template_point.id}: {'红色' if is_red else '非红色'}")
            
            if is_red:
                # 创建红色光点副本
                red_point = LightPoint(
                    id=template_point.id,
                    center_x=template_point.center_x,
                    center_y=template_point.center_y,
                    area=template_point.area,
                    contour=template_point.contour,
                    baseline_is_red=True,
                    current_is_red=True
                )
                red_light_points.append(red_point)
        
        self.logger.info(f"红色光点检测完成: 检测到 {len(red_light_points)}/{len(self.light_points_template)} 个红色光点")
        return red_light_points
    
    def _compare_light_points(self, baseline_points: List[LightPoint], frame: np.ndarray) -> Tuple[int, int]:
        """比较当前帧与基线的光点变化"""
        # 获取当前帧中的红色光点
        current_red_points = self._extract_red_light_points(frame)
        
        # 创建ID集合进行比较
        baseline_red_ids = {point.id for point in baseline_points}
        current_red_ids = {point.id for point in current_red_points}
        
        # 计算变化
        disappeared_ids = baseline_red_ids - current_red_ids  # 基线有但现在没有的
        appeared_ids = current_red_ids - baseline_red_ids     # 基线没有但现在有的
        
        total_changes = len(disappeared_ids) + len(appeared_ids)
        current_count = len(current_red_points)
        
        return current_count, total_changes
    
    def initialize_cameras(self) -> bool:
        """初始化摄像头"""
        # 限制最大摄像头数量，避免配置错误
        max_cameras = min(self.config.cameras.count, 6)
        self.logger.info(f"初始化 {max_cameras} 个摄像头 (配置: {self.config.cameras.count})...")
        
        self.cameras = [None] * max_cameras
        
        for camera_id in range(max_cameras):
            try:
                # 延迟初始化避免冲突
                if camera_id > 0:
                    time.sleep(0.3)
                
                self.logger.info(f"初始化摄像头 {camera_id}...")
                
                # 使用DirectShow后端
                cap = None
                for attempt in range(3):
                    try:
                        cap = cv2.VideoCapture(camera_id, cv2.CAP_DSHOW)
                        if cap.isOpened():
                            break
                        if cap:
                            cap.release()
                        time.sleep(0.5)
                    except Exception as e:
                        self.logger.warning(f"摄像头 {camera_id} 初始化尝试 {attempt+1} 失败: {e}")
                        if cap:
                            cap.release()
                        cap = None
                
                if not cap or not cap.isOpened():
                    self.logger.warning(f"摄像头 {camera_id} 无法打开")
                    if cap:
                        cap.release()
                    continue
                
                # 配置摄像头为1080p
                cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1920)
                cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1080)
                cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
                cap.set(cv2.CAP_PROP_FPS, 30)
                
                # 设置曝光参数
                cap.set(cv2.CAP_PROP_AUTO_EXPOSURE, 0.25)
                cap.set(cv2.CAP_PROP_EXPOSURE, self.config.cameras.exposure)
                cap.set(cv2.CAP_PROP_BRIGHTNESS, self.config.cameras.brightness / 100.0)
                cap.set(cv2.CAP_PROP_CONTRAST, self.config.cameras.contrast / 100.0)
                cap.set(cv2.CAP_PROP_SATURATION, self.config.cameras.saturation / 100.0)
                
                # 预热摄像头
                for _ in range(5):
                    ret, frame = cap.read()
                    if ret and frame is not None:
                        break
                    time.sleep(0.1)
                
                if ret and frame is not None:
                    # 验证分辨率
                    actual_shape = frame.shape
                    self.logger.info(f"摄像头 {camera_id} 实际分辨率: {actual_shape}")
                    
                    self.cameras[camera_id] = cap
                    self.camera_states[camera_id] = CameraLightPointState(camera_id)
                    self.logger.info(f"摄像头 {camera_id} 初始化成功")
                else:
                    self.logger.warning(f"摄像头 {camera_id} 无法读取帧")
                    cap.release()
                    
            except Exception as e:
                self.logger.error(f"摄像头 {camera_id} 初始化失败: {e}")
        
        active_cameras = len([c for c in self.cameras if c is not None])
        self.logger.info(f"成功初始化 {active_cameras} 个摄像头")
        
        return active_cameras > 0
    
    def initialize_mqtt(self) -> bool:
        """初始化MQTT连接"""
        try:
            self.logger.info("初始化MQTT连接...")
            
            from copy import deepcopy
            mqtt_config = deepcopy(self.config.mqtt)
            mqtt_config.client_id = "receiver"
            self.mqtt_client = MQTTClient(mqtt_config)
            if self.mqtt_client.connect():
                self.mqtt_client.set_message_callback(self._handle_mqtt_message)
                self.logger.info(f"MQTT接收客户端连接成功 (Client ID: {mqtt_config.client_id})")
            else:
                self.logger.error("MQTT接收客户端连接失败")
                return False
            
            self.logger.info("MQTT初始化完成，使用单一receiver客户端")
            return True
            
        except Exception as e:
            self.logger.error(f"MQTT初始化失败: {e}")
            return False
    
    def _handle_mqtt_message(self, message_data: Dict) -> None:
        """处理MQTT消息"""
        try:
            payload_data = message_data.get('payload', {})
            ones_count = payload_data.get('count_of_ones', 0)
            is_update = message_data.get('is_update', False)
            
            self.logger.info(f"收到MQTT消息: {ones_count} ones, 更新: {is_update}")
            
            # 获取配置参数
            exclude_ones = getattr(self.config.red_light_detection, 'exclude_ones_count', 144)
            require_update = getattr(self.config.red_light_detection, 'require_content_update', True)
            
            # 优先检查排除条件
            if ones_count == exclude_ones:
                self.logger.info(f"检测到{exclude_ones}个ones，强制跳过基线建立")
                return
            
            # 检查其他基线建立条件
            should_establish_baseline = False
            reason = ""
            
            if ones_count == 0:
                reason = f"ones数量为0"
                self.logger.debug(f"{reason}，跳过基线建立")
            elif require_update and not is_update:
                reason = f"changeState内容无更新"
                self.logger.debug(f"{reason}，跳过基线建立")
            elif ones_count > 0 and (not require_update or is_update):
                should_establish_baseline = True
                reason = f"满足所有条件"
            
            if should_establish_baseline:
                self.logger.info(f"[OK] 基线建立条件满足: ones={ones_count}, 更新={is_update}, 开始基线建立")
                self.mqtt_triggered = True
                self.baseline_capture_time = time.time() + 0.1
                
                # 重置所有摄像头状态
                with self.detection_lock:
                    for state in self.camera_states.values():
                        state.baseline_established = False
                        state.light_points = None
                        state.baseline_red_count = 0
                        state.current_red_count = 0
                        state.detection_count = 0
            else:
                self.logger.info(f"[SKIP] 基线建立条件不满足: {reason}")
                
        except Exception as e:
            self.logger.error(f"处理MQTT消息错误: {e}")
    
    def capture_baseline(self) -> None:
        """捕获基线数据 - 只采集红色光点"""
        self.logger.info("开始捕获红色光点基线数据...")
        
        with self.detection_lock:
            for camera_id, cap in enumerate(self.cameras):
                if cap is None or camera_id not in self.camera_states:
                    continue
                
                try:
                    # 捕获帧
                    ret, frame = cap.read()
                    if not ret or frame is None:
                        self.logger.warning(f"摄像头 {camera_id} 无法捕获基线帧")
                        continue
                    
                    # 提取红色光点
                    red_light_points = self._extract_red_light_points(frame)
                    
                    # 设置基线
                    state = self.camera_states[camera_id]
                    state.light_points = red_light_points
                    state.baseline_red_count = len(red_light_points)
                    state.current_red_count = len(red_light_points)
                    state.baseline_established = True
                    state.last_detection_time = time.time()
                    
                    self.logger.info(f"摄像头 {camera_id} 基线设置: 红色光点数={len(red_light_points)}/{len(self.light_points_template)}")
                    
                except Exception as e:
                    self.logger.error(f"摄像头 {camera_id} 基线捕获失败: {e}")
        
        self.logger.info("基线捕获完成")
    
    def detect_and_compare(self) -> None:
        """检测并比较光点变化"""
        current_time = time.time()
        
        with self.detection_lock:
            for camera_id, cap in enumerate(self.cameras):
                if cap is None or camera_id not in self.camera_states:
                    continue
                
                state = self.camera_states[camera_id]
                
                # 检查是否需要检测
                if not state.baseline_established or state.light_points is None:
                    continue
                
                # 检查检测间隔（0.2秒）
                if current_time - state.last_detection_time < 0.2:
                    continue
                
                try:
                    # 捕获帧
                    ret, frame = cap.read()
                    if not ret or frame is None:
                        continue
                    
                    # 比较光点变化
                    current_count, change_count = self._compare_light_points(state.light_points, frame)
                    state.detection_count += 1
                    state.last_detection_time = current_time
                    state.current_red_count = current_count
                    
                    # 检查是否有显著变化 - 相差1个光点就触发
                    count_difference = abs(current_count - state.baseline_red_count)
                    if count_difference >= 1:
                        self.logger.info(f"摄像头 {camera_id} 检测到光点变化: "
                                       f"基线={state.baseline_red_count}, "
                                       f"当前={current_count}, "
                                       f"差异={count_difference}个光点")
                        
                        # 触发MQTT消息
                        self._trigger_mqtt_message(camera_id, count_difference)
                    
                    # 定期输出状态
                    if state.detection_count % 25 == 0:  # 每5秒输出一次
                        self.logger.info(f"摄像头 {camera_id} 状态: "
                                       f"总光点数={len(self.light_points_template)}, "
                                       f"基线红色光点数={state.baseline_red_count}, "
                                       f"当前红色光点数={current_count}, "
                                       f"检测次数={state.detection_count}")
                    
                except Exception as e:
                    self.logger.error(f"摄像头 {camera_id} 检测失败: {e}")
    
    def _trigger_mqtt_message(self, camera_id: int, change_count: int) -> None:
        """触发MQTT消息"""
        try:
            if self.mqtt_client and self.mqtt_client.client:
                result = self.mqtt_client.client.publish(
                    self.config.mqtt.publish_topic, 
                    payload=""
                )
                
                if result.rc == 0:
                    self.logger.info(f"摄像头 {camera_id} 触发MQTT消息成功 (光点变化: {change_count})")
                else:
                    self.logger.error(f"摄像头 {camera_id} 触发MQTT消息失败: {result.rc}")
            else:
                self.logger.error("MQTT客户端未连接，无法发送触发消息")
            
        except Exception as e:
            self.logger.error(f"触发MQTT消息错误: {e}")
    
    def detection_loop(self) -> None:
        """检测循环"""
        self.logger.info("开始光点检测循环")
        
        while self.running:
            try:
                current_time = time.time()
                
                # 检查是否需要捕获基线
                if self.mqtt_triggered and current_time >= self.baseline_capture_time:
                    self.capture_baseline()
                    self.mqtt_triggered = False
                
                # 执行检测和比较
                self.detect_and_compare()
                
                # 短暂休眠
                time.sleep(0.05)  # 20 FPS检测频率
                
            except Exception as e:
                self.logger.error(f"检测循环错误: {e}")
                time.sleep(1)
        
        self.logger.info("检测循环结束")
    
    def start(self) -> bool:
        """启动系统"""
        try:
            self.logger.info("启动基于mask.png的光点检测系统")
            
            # 初始化摄像头
            if not self.initialize_cameras():
                self.logger.error("摄像头初始化失败")
                return False
            
            # 初始化MQTT
            mqtt_ok = self.initialize_mqtt()
            if not mqtt_ok:
                self.logger.warning("MQTT初始化失败，继续运行检测功能")
            
            # 启动检测线程
            self.running = True
            self.detection_thread = threading.Thread(target=self.detection_loop, daemon=True)
            self.detection_thread.start()
            
            self.logger.info("基于mask.png的光点检测系统启动成功")
            return True
            
        except Exception as e:
            self.logger.error(f"系统启动失败: {e}")
            return False
    
    def stop(self) -> None:
        """停止系统"""
        try:
            self.logger.info("停止基于mask.png的光点检测系统")
            
            self.running = False
            
            # 等待检测线程结束
            if self.detection_thread and self.detection_thread.is_alive():
                self.detection_thread.join(timeout=2.0)
            
            # 释放摄像头
            for cap in self.cameras:
                if cap is not None:
                    cap.release()
            
            # 断开MQTT连接
            if self.mqtt_client:
                self.mqtt_client.disconnect()
            
            self.logger.info("基于mask.png的光点检测系统已停止")
            
        except Exception as e:
            self.logger.error(f"系统停止错误: {e}")
    
    def get_status(self) -> Dict:
        """获取系统状态"""
        with self.detection_lock:
            status = {
                'running': self.running,
                'mqtt_triggered': self.mqtt_triggered,
                'active_cameras': len([c for c in self.cameras if c is not None]),
                'total_light_points': len(self.light_points_template),
                'camera_states': {}
            }
            
            for camera_id, state in self.camera_states.items():
                status['camera_states'][camera_id] = {
                    'baseline_established': state.baseline_established,
                    'baseline_red_count': state.baseline_red_count,
                    'current_red_count': state.current_red_count,
                    'detection_count': state.detection_count
                }
            
            return status

def setup_logging():
    """设置日志"""
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.DEBUG)  # 改为DEBUG级别
    
    file_handler = logging.FileHandler('mask_lightpoint_detection.log', encoding='utf-8')
    file_handler.setLevel(logging.DEBUG)  # 改为DEBUG级别
    
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    console_handler.setFormatter(formatter)
    file_handler.setFormatter(formatter)
    
    logging.basicConfig(
        level=logging.DEBUG,  # 改为DEBUG级别
        handlers=[console_handler, file_handler]
    )

def main():
    """主函数"""
    print("=== 基于mask.png的光点检测系统 ===")
    print("将mask中的每个白色连通区域识别为一个独立的光点")
    print("只检测红色光点的出现和消失")
    print("按 Ctrl+C 退出")
    print()
    
    setup_logging()
    logger = logging.getLogger(__name__)
    
    # 检查mask文件
    mask_file = "mask.png"
    if not os.path.exists(mask_file):
        print(f"[ERROR] 未找到mask文件: {mask_file}")
        print("请确保mask.png文件存在于当前目录")
        return 1
    
    system = None
    
    try:
        # 创建检测系统
        system = MaskLightPointDetectionSystem(mask_file=mask_file)
        
        # 启动系统
        if not system.start():
            logger.error("系统启动失败")
            return 1
        
        # 主循环 - 定期输出状态
        while True:
            time.sleep(10)  # 每10秒输出状态
            
            status = system.get_status()
            logger.info(f"系统状态: 运行={status['running']}, "
                       f"活跃摄像头={status['active_cameras']}, "
                       f"总光点数={status['total_light_points']}, "
                       f"MQTT触发={status['mqtt_triggered']}")
            
            # 输出摄像头状态
            for camera_id, state in status['camera_states'].items():
                if state['baseline_established']:
                    logger.info(f"摄像头 {camera_id}: "
                               f"基线红色光点数={state['baseline_red_count']}, "
                               f"当前红色光点数={state['current_red_count']}, "
                               f"检测次数={state['detection_count']}")
    
    except KeyboardInterrupt:
        logger.info("用户中断")
    except Exception as e:
        logger.error(f"系统错误: {e}")
        return 1
    finally:
        if system:
            system.stop()
    
    return 0

if __name__ == "__main__":
    sys.exit(main())